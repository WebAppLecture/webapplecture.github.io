<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Webapplecture</title>
    <link rel="shortcut icon" href="resources/images/html5.png">
    <link rel="stylesheet" href="resources/css/main.css"/>
    <link rel="stylesheet" href="resources/css/codeEditor.css"/>
    <link rel="stylesheet" href="resources/css/codeDisplay.css"/>
    <link rel="stylesheet" href="resources/css/buttons.css"/>
    <link rel="stylesheet" href="resources/css/header.css"/>
</head>
<body>
<header>
    <div class="wrapper">
        <img src="resources/images/html5.png">
        <nav>
            <ul>
                <li>
                    <h2>Tag</h2>
                </li>
                <li>
                    <a href="index.html"><h2>0</h2></a>
                </li>
                <li>
                    <a href="day1.html"><h2>1</h2></a>
                </li>
                <li>
                    <a href="day2.html"><h2>2</h2></a>
                </li>
                <li>
                    <a href="day3.html"><h2>3</h2></a>
                </li>
                <li>
                    <a href="day4.html"><h2>4</h2></a>
                </li>
                <li>
                    <a href="day5.html"><h2>5</h2></a>
                </li>
                <li>
                    <a href="day6.html"><h2>6</h2></a>
                </li>
                <li>
                    <a href="day7.html"><h2>7</h2></a>
                </li>
                <li>
                    <h2>Übung</h2>
                </li>
                <li>
                    <a href="exercises.html"><h2>1</h2></a>
                </li>
                <li>
                    <a href="exercises.html"><h2>2</h2></a>
                </li>
                <li>
                    <a href="exercises.html"><h2>3</h2></a>
                </li>
                <li>
                    <a href="exercises.html"><h2>4</h2></a>
                </li>
                <li>
                    <a href="exercises.html"><h2>5</h2></a>
                </li>
            </ul>
        </nav>
        <span id="toTop">
            <a><h2>Top</h2></a>
        </span>
    </div>
</header>
<div class="wrapper">
<nav class="column left">

</nav>
<main class="column middle">
<section id="JavaScript-Grundlagen">
    <article>
        <h2>Einstieg in JavaScript</h2>
        <ul>
            <li>JavaScript hat gar nichts mit Java gemein - der ursprüngliche Name ist LiveScript</li>
            <li>Ziel und Zweck: Fähigkeiten von Webseiten verbessern und eine dynamische Webseite auf dem Client zu erzeugen</li>
            <li>Heute kann man mit Hilfe von Hilfsumgebungen jedoch JavaScript für jegliche Anwedung auf jeglicher Platform benutzen. Eigenständige Programme für Desktops, Serverapplikationen, Smartphoneapps und sogar Mikrokontroller können heute mit JavaScript erstellt werden.
            <li>JavaScript kann in einem HTML Dokument geschrieben oder von extern eingebunden werden</li>
            <li>Ein Beispiel für direkte Einbindung (im Dokument):<br>
            <code>&lt;script&gt;/*Javascript Kommentar */&lt;/script&gt;</code>
            </li>
            <li>Ein Beispiel für indirekte (externe) Einbindung:<br>
            <code>&lt;script src="pfad/zum/beispiel.js"&gt;&lt;/script&gt;</code>
            </li>
            <li>Ein Beispiel für die indirekte Einbindung als Modul:<br>
            <code>&lt;script type="module" src="pfad/zum/beispiel.js"&gt;&lt;/script&gt;</code>
            <li>Durch den Wettkampf unter den Browser Herstellern werden die JavaScript-Engines immer schneller, zur Zeit führt Google's <strong>Chrome V8</strong> Javascript Engine hier deutlich. Dieser Engine ist Open-Source und wird von allen Chromium basierten Browsern benutzt. (Dies beinhaltet bald auch Microsoft Edge)</li>
        </ul>
    </article>
    <article>
        <h2>ECMA Script</h2>
        <ul>
            <li>ECMA Script bezeichnet den Sprachkern auf dem JavaScript und CoffeeScript basieren.</li>
            <li>Seit Juni 2015 gibt es Version 6 "Harmony"</li>
            <li>Zum jetzigen Stand (Februar 2019) ist die Prozentsatz an unterstüzter ES 6 Funktionalität wie folgt
            <ul>
                <li>Chrome V8 basierte Browser: 98%</li>
                <li>SpiderMoney basierte Browser (Firefox): 98%</li>
                <li>Chakra basierte Browser (MS Edge): 96%</li>
                <li>JavascriptCore basierte Browser (Safari, IOS): 99% (hier fehlt nur ein Syntaxupdate)</li>
                <li>Samsung 8.2: 97%</li>
                <li>Node.js V11+: 98%</li>
            </ul>
            </li>
            <li>Es gibt Programme, die es erlauben ES 6 Code in ES 5 zu übersetzen (Babel, Traceur; Implementierung liegt hier bei 50-70%)</li>
            <li>ES 6 enthält einige Neuerungen, die die "JavaScript-Strangeness" vermindern</li>
            <li>Die für uns interessantesten Features sind
            <ul>
                <li>Verwendung von Klassen und Modulen</li>
                <li>Variablen-Deklaration mit <code>const</code> und <code>let</code></li>
                <li>DOM Element Selektion mit <code>document.querySelector</code></li>
            </ul>
            </li>
        </ul>
    </article>
    <article>
        <h2>Javascript Verstehen</h2>
        <ul>
            <li>Objekte
                <ul>
                    <li>Objekte kapseln Eigenschaften und Methoden (Schnittstelle!)</li>
                    <li>Objekte ermöglichen uns Zugriff auf Elemente einer Webseite</li>
                    <li>z.B. können wir mit dem <code>window</code> Objekt auf den aktuellen Kontext zugreifen</li>
                </ul>
            </li>
            <li>Methoden
                <ul>
                    <li>Aktive Schnittstelle eines Objektes (zum Ausführen einer Aktion)</li>
                    <li>Wenn unabhängig vom Kontext kann man von einer Funktion sprechen</li>
                    <li>z.B. schließt <code>window.close()</code> das aktuelle Fenster (Tab) komplett</li>
                </ul>
            </li>
            <li>Eigenschaften
                <ul>
                    <li>Verkörpern Merkmale des Objektes (sog. passive Schnittstelle)</li>
                    <li>Eigenschaften geben Informationen über den Zustand des Objektes</li>
                    <li>z.B. setzt <code>document.bgColor = "FF0000"</code> die Hintergrundfarbe auf rot</li>
                </ul>
            </li>
        </ul>
    </article>
    <article>
        <h2>Variablen und Datentypen</h2>
        <figure><img src="resources/images/slides/jsdatatypes.png" alt="Die verschiedenen JavaScript Datentypen"><figcaption>Auflistung der verschiedenen JavaScript Datentypen</figcaption></figure>
        <ul>
        <li>Es gibt 6 elementare Typen: <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>undefined</code>, <code>Function</code> und <code>Object</code></li>
        <li>Alle anderen Typen (z.B. <code>Array</code>) bauen auf <code>Object</code> auf (auch <code>null</code>)</li>
        <li>Unter Variablen verstehen wir Speicher für Objekte und Werte (z.B. gilt Zahl = Wert und String = Objekt)</li>
        <li>Deklaration einer Variablen erfolgt mit ihrer ersten Aufzählung (Lokal: <code>var</code> davor, z.B. <code>var i = 2</code>)</li>
        </ul>
    </article>
    <article>    
        <h2>Variable ist nicht Variable</h2>
        <p>Mit ES 6 sind neben <code>var</code> noch zwei weitere Bezeichner für Variablen hinzugekommen: <code>const</code> und <code>let</code></p>
        <ul>
            <li><code>const</code> bezeichnet eine nicht veränderbare Konstante:
            <div id="js-bsp-2" class="codeEditor" data-language="js">
                <div class="container" style="height: 180px">
                    <pre class="source hidden">
                        function(input, output) {
                            // Fehler in der Konsole -> Öffnen mit F12
                            //Konvention: Verwende GROSSBUCHSTABEN für Konstanten
                            const PI = 3.14; 
                            PI = 4; //nicht möglich - Type Error
                        }
                    </pre>
                </div>
            </div>
            </li>
            <li>Der Unterschied zwischen <code>let</code> und <code>var</code> ist nicht so offensichtlich: Sie zeigen verschiedenes Scoping Verhalten
                <div id="js-bsp-3" class="codeEditor" data-language="js">
                    <div class="container" style="height: 180px">
                        <pre class="source hidden">
                            function(input, output) {
                                //Teste den Code einmal mit let und einmal mit var
                                for(let a = 5; a < 10; a++) {
                                    output.value += a + ", ";
                                }
                                alert(a);
                            }
                        </pre>
                    </div>
                </div>
            <ul>
                <li>Kontext von <code>let</code>: { /* Existent innerhalb dieser Klammern, ab Zeitpunkt der Deklaration */ } </li>
                <li>Kontext von <code>var</code>: function(){ /* Existent ab Beginn der <em>Funktion</em> in der sie definiert wurde */ }
            </li></ul>
            </li>
            </ul>
            <p>Wenn ES 6 in eurem Projekt verwendet wird, empfiehlt es sich in den meisten Fällen <code>let</code> statt <code>var</code> zu verwenden, da es sich <em>gewohnter</em> verhält was das Scoping angeht, nicht gehoisted wird und einen Fehler produziert, wenn man die Variable zweimal deklariert. Wenn ihr Module verwendet fällt das Problem teilweise weg, da es keinen Globalen Namespace mehr gibt.</p>
    </article>
    <article>
        <h2>Arrays (1)</h2>
        <ul>
        <li>Damit sich hinter einer Variablen mehr Objekte verstecken können, muss es sich um ein Array handeln</li>
        <li>Arrays können auf sehr unterschiedliche Art und Weise initialisiert werden:
            <div id="js-bsp-4" class="codeEditor" data-language="js">
                <div class="container" style="height: 190px">
                    <pre class="source hidden">
                        function(input, output) {
                            let leer1 = []; //Empfohlen
                            let leer2 = new Array(); //Nicht empfohlen
                            let reserviert = new Array(14); 
                            //Bringt keine Performance-Vorteile
                            let belegt1 = new Array('Milch', 'Zucker', 'Mehl');
                            let belegt2 = ['Milch', 'Mehl', 'Äpfel'];
                        }
                    </pre>
                </div>
            </div>
        </li>
        <li>Möglichkeiten zum Hinzufügen eines Elements mit <code>push()</code> (ans Ende) und <code>unshift()</code> (an den Anfang)
            <div id="js-bsp-5" class="codeEditor" data-language="js">
                <div class="container" style="height: 150px">
                    <pre class="source hidden">
                        function(input, output) {
                            let array = output.value.split("\n");
                            array.push(input.value); // probiers doch aus
                            output.value = "";
                            output.value += array.join("\n");
                        }
                    </pre>
                </div>
            </div>
        </li>
        <li>Der Zugriff auf Array Elemente erfolgt über eckige Klammern, z.B.
            <div id="js-bsp-6" class="codeEditor" data-language="js">
                <div class="container" style="height: 150px">
                    <pre class="source hidden">
                        function(input, output) {
                            let lang = ['C#', 'Java', 'C++'];
                            output.value = lang[1];
                            output.value += "\n";
                            output.value += lang[3]; // geht das überhaupt?
                        }
                    </pre>
                </div>
            </div>
        </li>
        <li>Der Zugriff ist 0 basiert, wie in anderen C ähnlichen Sprachen</li>
        <li>Bei nicht-definierten Zugriffen gibt es keinen Fehler, sondern <code>undefined</code> als Rückgabe</li>
        </ul>
    </article>
    <article>
        <h2>Arrays (2)</h2>
        <ul>
        <li>Die Eigenschaft <code>length</code> gibt eine Zahl zurück, welche 1 größer als der größte Integer Key ist</li>
        <li>Mit <code>sort()</code> können wir das Array sortieren - optional unter Angabe einer Sortierfunktion</li>
        <li>Standardmäßig wird nur die Stringdarstellung sortiert, z.B.
            <div id="js-bsp-7" class="codeEditor" data-language="js">
                <div class="container" style="height: 165px">
                    <pre class="source hidden">
                        function(input, output) {
                            var a = [1, 5, 12, 23, 100];
                            input.value = a.sort();//1 100 12 23 5
                            output.value = a.sort(function(a,b) { 
                                return a-b;
                            }); //1 5 12 23 100
                        }
                    </pre>
                </div>
            </div>
        </li>
        <li>Zum Entfernen mit <code>splice()</code> wird der Index und die Anzahl benötigt oder wir löschen das letzte mit <code>pop()</code>
            <div id="js-bsp-8" class="codeEditor" data-language="js">
                <div class="container" style="height: 225px">
                    <pre class="source hidden">
                        function(input, output) {
                            var kundenliste = 
                            ['Herbert Maier','Max Hilbert', 'Anton Mustermann'];
                            input.value = kundenliste;
                            input.value += " - " + kundenliste.length; // 3
                            kundenliste.splice(0, 2);
                            //Entfernt zwei Einträge ab Index 0
                            output.value = kundenliste;
                            output.value += " - " + kundenliste.length; // 1
                        }
                    </pre>
                </div>
            </div>
        </li>
        <li>Mit <code>includes()</code> kann ein Array auf die Existenz eines Eintrags überprüft werden
            <div id="js-bsp-9" class="codeEditor" data-language="js">
                <div class="container" style="height: 105px">
                    <pre class="source hidden">
                        function(input, output) {
                            let array = ['C#','Java','Python','Ruby'];
                            output.value = array.includes(input.value);
                        }
                    </pre>
                </div>
            </div>
        </li>
        </ul>
    </article>
    <article>
        <h2>Operatoren</h2>
        <ul>
        <li>Operatoren sind reservierte Zeichen, die Operationen (z.B. Addition) ausführen</li>
        <li>Es gibt: Logik-, Arithmetik-, Bit- und Vergleichsoperatoren (sowie Condition <code>?</code> und Assignment <code>=</code>)</li>
        <li>Genau wie in anderen Sprachen gibt es bei manchen Operatoren Prä- (<code>++i</code>) und Suffixdarstellungen (<code>i++</code>)</li>
        <li>Es gibt zu beachten - JavaScript nimmt einiges nicht so genau, z.B. ist <code>'0'</code> gleich <code>0</code> bei <code>==</code></li>
        <li>Daher gibt es <strong>zwei weitere Operatoren</strong> (<code>===</code> und <code>!==</code>) - diese vergleichen Wert <strong>und</strong> Typ</li>
        <li>Außerdem ist die <code>0</code> <u>nicht</u> vorzeichenlos - dies kann zu verwirrenden Ergebnissen führen (<code>a/0 != a/(-0)</code>)</li>
        </ul>
        <br><br><br>
        <table>
        <thead>
        <tr>
        <th>
        Arithmetische Operatoren
        </th>
        <th>
        Vergleichsoperatoren
        </th>
        <th>
        Weitere Operatoren
        </th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td width="33%">
        <table class="small">
        <thead>
            <tr>
                <th>Op.</th>
                <th>Bedeutung</th>
                <th>Beispiel</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>+</td>
                <td>Addition</td>
                <td><code>3 + 4</code> ergibt <code>7</code></td>
            </tr>
            <tr>
                <td>++</td>
                <td>Inkrement</td>
                <td><code>i=3;i++</code> ergibt <code>4</code></td>
            </tr>
            <tr>
                <td>-</td>
                <td>Subtraktion</td>
                <td><code>3 - 4</code> ergibt <code>-1</code></td>
            </tr>
            <tr>
                <td>--</td>
                <td>Dekrement</td>
                <td><code>i=3;i--</code> ergibt <code>2</code></td>
            </tr>
            <tr>
                <td>*</td>
                <td>Multiplikation</td>
                <td><code>3 * 4</code> ergibt <code>12</code></td>
            </tr>
            <tr>
                <td>/</td>
                <td>Division</td>
                <td><code>3 / 4</code> ergibt <code>0.75</code></td>
            </tr>
            <tr>
                <td>%</td>
                <td>Modulo</td>
                <td><code>5 % 4</code> ergibt <code>1</code></td>
            </tr>
            <tr>
                <td>**</td>
                <td>Potenzierung</td>
                <td><code>2 ** 3</code> ergibt <code>8</code></td>
            </tr>
        </tbody>
        </table>

        </td><td width="33%">
        <table class="small">
        <thead>
            <tr>
                <th>Op.</th>
                <th>Bedeutung</th>
                <th>Beispiel</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>==</td>
                <td>gleich</td>
                <td><code>3 == '3'</code> ergibt <code>true</code></td>
            </tr>
            <tr>
                <td>!=</td>
                <td>ungleich</td>
                <td><code>3 != 3</code> ergibt <code>false</code></td>
            </tr>
            <tr>
                <td>===</td>
                <td>typgleich</td>
                <td><code>3 === 3</code> ergibt <code>true</code></td>
            </tr>
            <tr>
                <td>!==</td>
                <td>typungleich</td>
                <td><code>3 !== '3'</code> ergibt <code>true</code></td>
            </tr>
            <tr>
                <td>&lt;</td>
                <td>kleiner</td>
                <td><code>3 &lt; 4</code> ergibt <code>true</code></td>
            </tr>
            <tr>
                <td>&lt;=</td>
                <td>kleiner gleich</td>
                <td><code>4 &lt;= 3</code> ergibt <code>false</code></td>
            </tr>
            <tr>
                <td>&gt;</td>
                <td>größer</td>
                <td><code>3 &gt; 4</code> ergibt <code>false</code></td>
            </tr>
            <tr>
                <td>&gt;=</td>
                <td>größer gleich</td>
                <td><code>4 &gt;= 3</code> ergibt <code>true</code></td>
            </tr>
        </tbody>
        </table>
        </td>
        <td width="33%">
        <table class="small">
        <thead>
            <tr>
                <th>Op.</th>
                <th>Bed.</th>
                <th>Beispiel</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>&amp;&amp;</td>
                <td>und</td>
                <td><code>true &amp;&amp; false</code> ergibt <code>false</code></td>
            </tr>
            <tr>
                <td>||</td>
                <td>oder</td>
                <td><code>true || false</code> ergibt <code>true</code></td>
            </tr>
            <tr>
                <td>!</td>
                <td>nicht</td>
                <td><code>!false</code> ergibt <code>true</code></td>
            </tr>
            <tr>
                <td>&amp;</td>
                <td>bit und</td>
                <td><code>2 &amp; 1</code> ergibt <code>0</code></td>
            </tr>
            <tr>
                <td>|</td>
                <td>bit oder</td>
                <td><code>2 | 1</code> ergibt <code>3</code></td>
            </tr>
            <tr>
                <td>~</td>
                <td>bit nicht</td>
                <td><code>~2</code> ergibt <code>-3</code></td>
            </tr>
        </tbody>
        </table>
        </td>
        </tr>
        </tbody>
        </table>
    </article>
    <article>
        <h2>Konvertieren mit Operatoren</h2>
            <ul>
            <li>Um eine boolsche Variable zu erhalten, ist doppelte Negation, d.h. <code>!!myvar</code> ausgezeichnet</li>
            <li>Strings kann man allgemein durch Addition mit einem String, z.B. <code>myvar + ''</code>, erhalten</li>
            <li>Alle Typen konvertieren zu Zahlen bei (fast) allen Operationen, z.B. <code>myvar * 1</code> oder <code>+myvar</code></li>
            <li>Wir können solche Zahlen auch runden, hier ist <code>~~myvar</code> geeignet</li>
            <div id="js-bsp-10" class="codeEditor" data-language="js">
                <div class="container" style="height: 125px">
                    <pre class="source hidden">
                        function(input, output) {
                            output.value = !!input.value + "\n";
                            output.value += input.value * 1 + "\n";
                            output.value += ~~input.value;
                        }
                    </pre>
                </div>
            </div>
            <li>Neben boolschen Werten, Zahlen und Strings können wir auch Standardwerte definieren</li>
            <li>So gibt <code>myvar || mydefault</code> immer <code>mydefault</code> zurück, außer <code>myvar</code> konvertiert zu <code>true</code></li>
            <li>Umgekehrt gibt <code>myvar &amp;&amp; mydefault</code> immer <code>myvar</code> zurück, außer <code>myvar</code> konvertiert zu <code>true</code></li>
            <li>Sinnvoll vor Konvertierungen sind auch die Operatoren <code>typeof</code> und <code>instanceof</code>, z.B.
            <div id="js-bsp-11" class="codeEditor" data-language="js">
                <div class="container" style="height: 185px">
                    <pre class="source hidden">
                        function(input, output) {
                            let o = input.value || {},
                                f = function() {};
                            output.value = (typeof o) + "\n";
                            output.value += ( o instanceof Object ) + "\n";
                            output.value += (typeof f) + "\n";
                            output.value += f instanceof Object;
                        }
                    </pre>
                </div>
            </div>
            </li>
            </ul>
    </article>
    <article>
        <h2>Kontrollstrukturen</h2>
        <ul>
        <li>Bis jetzt geht unser Code immer linear runter - keine Verzweigung möglich</li>
        <li>Viele (z.B. aus C) bekannte Schlüsselwörter gibt es auch hier:
        <ul>
        <li><code>for(_;_;_) {...}</code> für eine Zählerschleife (Vor Ausführung, Bedingung, Ende d. Iteration)</li>
        <li><code>for(...) {...}</code> für eine implizite Zählerschleife ("foreach"), z.B. <code>for(var name in names)</code></li>
        <li><code>while(_) {...}</code> für eine kopfgesteuerte Schleife (Bedingung)</li>
        <li><code>do {...} while(_);</code> für eine fußgesteuerte Schleife (Bedingung)</li>
        <li><code>switch(_) { case _: ... break; }</code> für eine Fallunterscheidung (Variable, Wert)</li>
        <li><code>if(_) {...} else {...}</code> für eine bedingte Anweisung (Bedingung)</li>
        </ul>
        </li>
        <li>Beachte den Unterschied zwischen <code>for(var name in names)</code> und <code>for(var name of names)</code>!
            <div id="js-bsp-12" class="codeEditor" data-language="js">
                <div class="container" style="height: 225px">
                    <pre class="source hidden">
                        function(input, output) {
                            output.value = "";
                            let names = ['C#','Java','Python','Ruby'];
                            for(n in names) {
                                output.value += n + ", " + names[n] + "\n"; 
                            }
                            for(name of names) {
                                output.value += name + "\n";    
                            }
                        }
                    </pre>
                </div>
            </div>
        </li>
        <li>Die Bedingung wird als boolscher Wert abgefragt - also <code>true</code> oder <code>false</code></li>
        <li>Bedingte Anweisungen können analog zu allen C ähnlichen Sprachen beliebig verschachtelt werden</li>
        <li>Um in Fallunterscheidungen einen Standardblock zu definieren, verwendet man anstelle von <code>case</code> das Schlüsselwort <code>default</code></li>
        </ul>
    </article>
    <article>
        <h2>Funktionen</h2>
        <ul>
        <li>Diese werden über das Schlüsselwort <code>function</code> erstellt, z.B. <code>function foo() {...}</code></li>
        <li>Besteht aus abgeschlossenem Block mit Anweisungen und (möglichen) Parametern</li>
        <li>Ziel ist die Kapslung von Anweisungen zur (variablen) Ausführung an beliebigen Stellen</li>
        <li>Jeder Parameter ist in JavaScript <strong>optional</strong> - daher können Funktionen nicht überladen werden</li>
        <li>In einer Funktion kann man über <code>arguments</code> (Array) auf alle übergebenen Parameter zugreifen</li>
        <li>Den Parametern Standardwerte zuzuweisen ist unsere Aufgabe - unbedingt beachten
            <div id="js-bsp-13" class="codeEditor" data-language="js">
                <div class="container" style="height: 105px">
                    <pre class="source hidden">
                        function() { // (input, output)
                            let a = arguments[0].value || "kein input!";
                            arguments[1].value = a;
                        }
                    </pre>
                </div>
            </div>
        </li>
        <li>Funktionsaufrufe geschehen über den Funktionsnamen und den Parameterwerten in Klammern</li>
        <li>Es ist möglich Methoden ohne anonyme Funktion zu erstellen (können direkt ausgeführt werden)</li>
        <li>JavaScript kennt keine explizit genannten Rückgabewerte, da die Sprache sowieso dynamisch ist</li>
        <li>Standardmäßig wird <code>undefined</code> zurückgegeben - außer man gibt mit <code>return</code> etwas zurück</li>
        <li>Wird in einer Funktion auf einen (bzw. den aktuellen) Kontext verwiesen, so ist dies eine Methode</li>
        <li>Wenn man Funktionen übergibt sollte man aufpassen ob man den Kontext per <code>.bind()</code> mitgeben sollte. <code>this</code> wechselt seinen Wert je nachdem wo die Funktion aufgerufen wird. (Siehe Sourcecode der CodeEditors!)</li>
        </ul>
    </article>
    <article>
        <h2>Beispiel Funktionen</h2>
        <div id="js-bsp-13" class="codeEditor" data-language="js">
            <div class="container" style="height: 500px">
                <pre class="source hidden">
                    function(input, output) { // (input, output)
                        switch(input.value) {
                            case 'sin':
                                output.value = 
                                    Math.sin(prompt('Sinusfunktion:', 144));
                                break;
                            //...
                            default:
                                output.value = 
                                    fibonacci(prompt('Fibonacci:', 0));
                        }

                        function fibonacci(n) {
                            //...
                            var t = 1, tp = 0;
                            for(var i = 2; i <= n; i++) {
                                var tmp = t; t = fib(t, tp); tp = tmp;
                            }
                            return t;
                        }
                    }
                </pre>
            </div>
        </div>
    </article>
    <article>
        <h2>Noch ein Wort zu Funktionen</h2>
        <p>Neben der Deklaration von Funktionen wie auf der vorherigen Slide gesehen gibt es noch zwei weitere Arten Funktionen zu definieren:</p>
        <ul>
        <li>Zuweisung an eine Variable:
        <div id="js-bsp-14" class="codeEditor" data-language="js">
            <div class="container" style="height: 105px">
                <pre class="source hidden">
                    function(input, output) { 
                        output.value = "Hallo " + input.value;
                        // z.B. 'Hallo Welt'
                    }
                </pre>
            </div>
        </div>
        Vorteil: Kein Nach-oben-ziehen (Hoisting) von Funktionen: Funktionen sind erst verwendbar wenn sie das erste mal zugewiesen werden</li>
        <li>Seit ES 6: Verwendung des "Fat-Arrow-Operators"
        <div id="js-bsp-15" class="codeEditor" data-language="js">
            <div class="container" style="height: 65px">
                <pre class="source hidden">
                    (input, output) => output.value = "Hallo " + input.value;
                </pre>
            </div>
        </div>
        <div id="js-bsp-16" class="codeEditor" data-language="js">
            <div class="container" style="height: 50px">
                <pre class="source hidden">
                    () => "Hi" //Kein Argument;
                </pre>
            </div>
        </div>
        <div id="js-bsp-17" class="codeEditor" data-language="js">
            <div class="container" style="height: 50px">
                <pre class="source hidden">
                    input => input.value * 3;
                </pre>
            </div>
        </div>
        Vorteil: Hauptächlich syntaktische Verbesserung - Man spart sich das Schreiben von function(){...}. Allerdings wird es im Zusammenhang mit Klassen interessant, weil der <code>this</code>-Zeiger unterschiedlich gebunden wird (dazu später mehr).
        </li>
        </ul>
    </article>
    <article>
        <h2>Arbeiten mit Zeichenketten</h2>
        <ul>
        <li>Strings (Zeichenketten) sind der am häufigsten benutzte Datentyp, da jede Eingabe zunächst ein String ist</li>
        <li>Strings zu manipulieren (verbinden, entfernen, suchen, ...) gehört daher zu den häufigsten Aufgaben</li>
        <li>JavaScript beherrscht von Grund auf sehr viele Methoden um mit Strings effizient arbeiten zu können</li>
        <li>Die Eigenschaft <code>length</code> gibt uns die Länge zurück z.B. ist <code>'hallo'.length</code> gleich 5</li>
        </ul>
        <div id="js-bsp-18" class="codeEditor" data-language="js">
            <div class="container" style="height: 250px">
                <pre class="source hidden">
                    function(input, output) {
                        let s = "Hallo Welt, Guten Tag!"
                        output.value = s.indexOf(input.value) + "\n";
                        output.value += s.lastIndexOf(input.value) + "\n";
                        output.value += s.split(input.value) + "\n";
                        output.value += s.split(input.value).slice(1,2) + "\n";
                        output.value += s.replace(input.value, "_") + "\n";
                        output.value += s.replaceAll(input.value, "_") + "\n";
                    }
                </pre>
            </div>
        </div>
        <div class="left">
        <h3>Einige wichtige Methoden</h3>
        <ul>
        <li><code>concat()</code></li>
        <li><code>indexOf()</code> und <code>lastIndexOf()</code></li>
        <li><code>match()</code></li>
        <li><code>replace()</code> (und <code>replaceAll()</code> per Prototyp Erweiterung)</li>
        <li><code>slice()</code> und <code>split()</code></li>
        <li><code>substr()</code> und <code>substring()</code></li>
        </ul>
        </div>
        <div class="right">
        <h3>Methoden mit HTML Ausgabe</h3>
        <ul>
        <li><code>link()</code></li>
        <li><code>bold()</code> und <code>italics()</code></li>
        <li><code>fixed()</code></li>
        <li><code>anchor()</code></li>
        <li><code>small()</code> und <code>strike()</code></li>
        <li><code>sub()</code> und <code>sup()</code></li>
        </ul>
        </div>
    </article>
    <article>
        <h2>Konvertieren von Strings</h2>
        <ul>
        <li>Wie erwähnt: Jede Eingabe erstmal ein String - wie wird dieser z.B. zu einer Zahl?</li>
        <li>Von einer Zahl zu einem String ist recht einfach z.B. bei <code>var i = 2</code> über var str = i.toString()</li>
        <li>Umgekehrt ist es nicht so einfach - eine Möglichkeit ist <code>var str = '123'</code> mit <code>var i = str * 1</code></li>
        <li>Was geschieht wenn wir aber folgendes verwenden: <code>var str = 'abc'</code>? Wir erhalten <code>i = NaN</code></li>
        <li><strong>NaN</strong> heißt <i>Not a Number</i> und ist ein spezieller Wert! Funktion zum Test ist <code>isNaN()</code></li>
        <li>Konvertierungsmethoden wie <code>parseInt()</code> und <code>parseFloat()</code> können auch verwendet werden</li>
        <li>Geben zwar auch im ungünstigen Fall <code>NaN</code> zurück - eignen sich aber sehr gut um wirklich Komma- oder Ganzzahl zu erhalten</li>
        <li>Boolsche Konvertierung: alles konvertiert, z.B. ergibt 0 oder auch <code>null</code> als Wert <code>false</code></li>
        <li>Arrays mit Elemente, Objekte mit Inhalten etc. ergeben als Wert <code>true</code></li>
        <li>Auswerten von Benutzereingabe: mit <strong>regulären Ausdrücken</strong> (<code>match()</code>) und Typüberprüfung arbeiten</li>
        <div id="js-bsp-18" class="codeEditor" data-language="js">
            <div class="container" style="height: 185px">
                <pre class="source hidden">
                    function(input, output) {
                        output.value = input.value * 1 + "\n";
                        output.value += isNaN(input.value * 1) + "\n";
                        output.value += parseInt(input.value) + "\n";
                        output.value += parseFloat(input.value) + "\n";
                        let regexp = new RegExp("[a-z]{3}[0-9]{5}", "g");
                        output.value += input.value.match(regexp);
                    }
                </pre>
            </div>
        </div>
        </ul>
    </article>
    <article>
    <h2>Fehler im Code finden</h2>
        <li>Fehler in Javascript zu finden funktioniert anders als bei compilierten Sprachen (keine Compilerfehler)</li>
        <li>Entweder über <code>console.log()</code> oder <code>alert()</code> eigene Kontrollen einbauen oder Entwicklertools nutzen</li>
        <li>Im Prinzip hat jeder der großen 5 Browser sehr gute Entwicklertools</li>
        <li>Die Entwicklungstools von Chrome sind sehr gut.</li>
        <li>Die Wichtigsten Tools:
            <ul>
            <li><strong>Console</strong> für Ausgaben von Fehlern und Ausprobieren von Code</li>
            <li><strong>DOM Inspektor</strong> um das DOM zu bearbeiten</li>
            <li><strong>Sources</strong> um z.B. Breakpoints für das Debuggen zu setzten</li>
            <li>Später auch <strong>Performance</strong> um die langsamen Codeteile zu identifizieren</li>
            <li>Wenn man mit Servern kommuniziert wird <strong>Network</strong> auch sehr wichtig</li>
            </ul>
        </li>
        </ul>
    </article>
</section>
<section id="Javascript-meets-HTML">
    <article>
        <h2>JavaScript in HTML nutzen</h2>
        <ul>
        <li>Einbindung erfolgt wie erwähnt über das <code>&lt;script&gt;</code> Element</li>
        <li>Allgemein wird JavaScript immer über sog. <strong>Ereignisse</strong> angesprochen</li>
        <li>Je nachdem um welches HTML Element es sich handelt, stehen andere Ereignisse zur Verfügung</li>
        <li>Beispiel: Bei vielen Elementen existiert das <code>onclick</code> Event, das beim Klicken ausgeführt wird:
        <div id="html-bsp-2" class="codeEditor" data-language="html">
            <div class="container" style="height: 100px">
                <pre class="source hidden">
                    <!--
                    <button onclick="alert('Das ist ein Test');">
                        Teste Mich!
                    </button>
                    -->
                </pre>
                <pre class="css-source hidden">
                </pre>
            </div>
        </div>
        </li>
        <li>Daneben können wir mit JavaScript noch Werte aus HTML auslesen und manipulieren:
        <ul>
        <li>Die Seite ist im <code>document</code> Objekt gekapselt (hier ist z.B. auch das <code>&lt;body&gt;</code> Element als Objekt enthalten)</li>
        <li>Um im <code>document</code> gezielt auf Elemente zuzugreifen benutzen wir <code>document.querySelector()</code> oder <code>document.querySelectorAll()</code> wenn wir mehrere Elemente suchen, der Selektor Syntax entspricht dem von CSS und jQuery.
            <ul>
            <li><code>querySelector("#target")</code> um auf <code>&lt;div id="target"&gt;</code> zuzugreifen.</li>
            <li><code>querySelector(".target")</code> um auf <code>&lt;div class="target"&gt;</code> zuzugreifen.</li>
            <li><code>querySelector("[data-value='33']")</code> um auf <code>&lt;div data-value="33"&gt;</code> zuzugreifen.</li>
            <li>Es gibt noch unzählige <a href="https://www.w3schools.com/cssref/css_selectors.asp">weitere Möglichkeiten</a>.</li>
            </ul>
        </li>
        </ul>
        </li>
        </ul>
    </article>
    <article>
        <h2>Interaktion über Ereignisse</h2>
        <div class="left">
        <ul>
        <li>Ereignisse (Events) sind Aktionen die von JavaScript detektiert werden können</li>
        <li>Jedes HTML Element hat einige bestimmte Ereignisse, die wir nutzen können</li>
        <li>Zunächst definieren wir die Ereignisbehandlung im HTML Tag des entsprechenden Elements</li>
        <li>Beispiele für Ereignisse:
        <ul>
        <li>Ein Mausklick (<code>onclick</code>)</li>
        <li>Absenden des Formulars (<code>onsubmit</code>)</li>
        <li>Eingabe / Änderung von Formelement (<code>onchange</code>)</li>
        <li>Betreten der Seite (<code>onload</code>)</li>
        <li>Mit der Maus über ein Element fahren (<code>onmouseover</code>)</li>
        </ul>
        </li>
        <li>JavaScript ist komplett ereignisgesteuert</li>
        </ul>
        </div>
        <div class="right">
        <figure><img src="resources/images/slides/events.png" alt="Ablauf von JavaScript Ereignissen"><figcaption>Der Nutzen von Ereignissen liegt in der Interaktion mit dem Benutzer</figcaption></figure>
        <figure><img src="resources/images/slides/selfevents.png" alt="JavaScript selbst auslösen"><figcaption>JavaScript benötigt keine Ereignisse zum Ausführen</figcaption></figure>
        </div>
    </article>
    <article>
        <h2>Beispiel Interaktion HTML/JS</h2>
        <ul>
            <li>Erst einmal Code ausführen!</li>
        </ul>
        <div id="html-bsp-3" class="codeEditor" data-language="html">
            <div class="container" style="height: 205px">
                <pre class="source hidden">
                    <!--
                    <div id="colorSetExample" style="background: none;">
                        <select>
                            <option>---</option>
                            <option value="#F00">Red</option>
                            <option value="#0F0">Green</option>
                            <option value="#00F">Blue</option>
                        </select>

                        <button>Anklicken</button>
                    </div>
                    -->
                </pre>
                <pre class="css-source hidden">
                </pre>
            </div>
        </div>
        <div id="js-bsp-19" class="codeEditor" data-language="js">
            <div class="container" style="height: 450px">
                <pre class="source hidden">
                    function(input, output) {
                        let colorDiv = 
                            document.querySelector("#colorSetExample"),
                            button =
                            colorDiv.querySelector("button"),
                            select =
                            colorDiv.querySelector("select");
                        button.addEventListener('click', 
                            setName.bind(button, colorDiv));
                        select.addEventListener('change', 
                            setColor.bind(select, colorDiv));

                        function setName(colorDiv) {
                            this.innerHTML = colorDiv.style.background;
                        }
                        function setColor(colorDiv) {
                            if(this.selectedIndex) {
                                colorDiv.style.background = 
                                    this.options[this.selectedIndex].value;
                            }
                        }

                    }
                </pre>
            </div>
        </div>
        <ul>
            <li>Beachte: <code>this</code> wird explizit per <code>bind()</code> gesetzt!</li>
        </ul>
    </article>
    <article>
        <h2>DOM Schnittstelle zu HTML</h2>
        <div class="left">
        <ul>
        <li>DOM = <strong>D</strong>ocument <strong>Ob</strong>ject <strong>M</strong>odel</li>
        <li>Nach dem sog. <strong>Parsen</strong> der HTML-Seite ist der DOM-Tree, der die Struktur der Seite repräsentiert, erstellt</li>
        <li>Die genauen Details interessieren uns nicht - für uns ist wichtig, dass wir durch den DOM einiges können:
        <ul>
        <li>Auf Elemente des Dokuments zugreifen</li>
        <li>Elemente zum Dokument hinzufügen (anhängen, einfügen, ...)</li>
        <li>Elemente des Dokuments entfernen</li>
        <li>Elemente des Dokuments bearbeiten (z.B. Eigenschaften)</li>
        </ul>
        </li><li>Die Änderungen am DOM werden vom Browser sofort bemerkt und daher sofort umgesetzt</li>
        <li>Wichtig: Objekte hinzuzufügen ist effizienter als <code>innerHTML</code> zu verändern</li>
        </ul>
        </div>
        <div class="right">
        <figure><img src="resources/images/slides/domparser.png" alt="Der DOM-Parser"><figcaption>Generierung des DOM durch den Parser (Webkit)</figcaption></figure>
        <figure><img src="resources/images/slides/domtree.png" alt="Beispielhafter DOM-Tree"><figcaption>Auswertung des DOM-Trees mit Vivaldi(Chromium)</figcaption></figure>
        </div>
    </article>
    <article>
        <h2>Das Window Objekt</h2>
        <div class="left">
        <ul>
        <li>Unser <code>document</code> liegt im aktuellen <code>window</code> Objekt</li>
        <li>Die Ereignisse des Fensters sind ziemlich zentraler Natur, z.B. <code>onerror</code> (JavaScript Fehler), <code>onfocus</code> (Fenster fokussiert),  sowie <code>onresize</code> und <code>onscroll</code> (Ändern der Fenstereigenschaften)
        </li><li>Wir können über <code>history</code> auch auf den Verlauf des aktuellen Fensters zugreifen</li>
        <li>Dank <code>frames</code> gibt es die Möglichkeit auf die (veralteten) frames und iframes zuzugreifen</li>
        <li>Eine Methode des Fensters haben wir schon öfters verwendet: <code>alert()</code> - daneben gibt es z.B. noch <code>confirm()</code> und <code>prompt()</code></li>
        <li>Über <code>window.open(url, 'Neues Fenster'[, options])</code> können wir ein neues Fenster (bzw. Tab) aufmachen, wobei <code>options</code> einen String darstellt</li>
        </ul>
        </div>
        <div class="right">
        <figure><img src="resources/images/slides/windowopen.png" alt="Optionen bei window.open()"><figcaption>Anschauliche Erklärung der möglichen Optionen beim Öffnen eines neuen Fensters mit JavaScript - die Angaben sind als Beispiel zu verstehen, wobei mehrere Angaben durch ein Komma getrennt werden</figcaption></figure>
        </div>
    </article>
</section>
<section id="Objektorientierte-Programmierung">
<article>
    <h2>Klassen in JavaScript (ab ES6)</h2>
    <div class="left">
    <ul>
    <li>In JavaScript gab es vor ES 6 <strong>kein</strong> Schlüsselwort um Klassen <strong>direkt</strong> zu erzeugen </li>
    <li>Jedoch bietet uns JS jetzt das <code>class</code> Schlüsselwort um Klassen zu erstellen </li>
    <li>Jede Klasse hat einen <code>constructor</code>, mit diesem werden Instanzen der Klasse erstellt </li>
    <li>Methoden in Klassen werden direkt mit ihrem Namen erstellt und sind danach als <code>Klasse.methodenName()</code> aufrufbar</li>
    <li>Interne Eigenschaften und Methoden einer Klasse müssen <strong>intern</strong> über das <code>this</code> Schlüsselwort aufgerufen werden!</li>
    </ul>
    </div>
    <div class="right">
    <code><pre>
        class NameDerKlasse {

            constructor(parameter) {
                this.parameter = parameter;
            }

            methodenName() {
                this.nochEineMethode();
            }

            nochEineMethode() {
                return this.parameter;
            }

        }
    </pre></code>
    </div>
</article>
<article>
    <h2>Namensräume und statische Felder</h2>
    <ul>
    <li>Namensräume verfolgen das Ziel Objekte voneinander abzugrenzen um Ordnung zu schaffen</li>
    <li>Wir können dies in JavaScript sehr leicht schaffen indem wir unsere Klassen in Objekte schachteln, z.B.
    <code><pre lang="javascript">
    let Namensraum = { };//Einen Namensraum erstellen
    Namensraum.Shape = class { ... }; //Die Klasse im Namensraum erstellen
    let instanz = new Namensraum.Shape(); //Instanz erstellen
    </pre></code>
    </li>
    <li>Statische Eigenschaften und Methoden (Felder) können ebenfalls hinzugefügt werden</li>
    <code><pre>
    class NameDerKlasse {

        constructor(parameter) {
            this.parameter = parameter;
        }

        static compare(a, b) {
            return a.parameter - b.parameter;
        }

    }
    </pre></code>
    <li>Statische Felder sind instanzlos (d.h. unabhängig) und können von jeder Instanz aufgerufen werden</li>
    <li>Statische Methoden sehen nur weitere statische bzw. im aktuellen Kontext vorhandene Felder</li>
    </ul>
    <h3>Private und Public</h3>
    <ul>
    <li>Gibt es in Javascript formal nicht!</li>
    <li>Es gibt jedoch viele Möglichkeiten dies zu emulieren, z.B. durch Scoping.</li>
    <li>Es ist in Javascript Konvention "private" Eigenschaften/Methoden mit einem Unterstrich zu markieren <code>_variable</code></li>
    <li>Man kann auch Module verwenden, da diese grundsätzlich Privat sind und nur explizit exportierte Eigenschaften oder Methoden freigeben </li>
    </ul>
</article>
<article>
    <h2>Setter und Getter</h2>
    <ul>
        <li>Mit Gettern und Settern kann man das setzen von Variablen einer Klasse besser kontrollieren</li>
        <li>Sie werden mit <code>get</code> bzw <code>set</code> Schlüsselwörtern markiert</li>
        <div id="js-bsp-1" class="codeEditor" data-language="js">
            <div class="container" style="height: 420px">
                <pre class="source hidden">
                    function(input, output) {
                        class User {

                            constructor(name) {
                                this.name = name; // ruft Setter auf
                            }

                            get name() {
                                return this._name;
                            }

                            set name(value) {
                                if (value.length < 4) {
                                    output.value = "Name ist zu kurz.";
                                    return;
                                }
                                this._name = value;
                            }
                        }
                        let user = new User(input.value);
                        output.value += "\n" + user.name;
                    }
                </pre>
            </div>
        </div>
    </ul>
</article>
</section>
<section id="Module (ab ES6)">
<article>
    <h2>Warum Module?</h2>
    <ul>
        <li>Nicht exportierte Variablen und Methoden sind nicht von außerhalb des Moduls erreichbar. (vergleichbar mit 'private' in anderen Sprachen)</li>
        <li>Die Zerlegung in kleinere gekapselte Programmteile fördert die Übersicht und Codequalität.</li>
        <li>Diese kleineren Module können leicht in anderen Projekten wiederverwendet werden.</li>
        <li>Modular geschriebene Programme erlauben sogenanntes "Tree Shaking", d.h. nicht verwendete Module werden nie geladen.</li>
        <li>Module können Webseitenübergreifend gecached werden.</li>
        <li>Module erlauben dynamisches Nachladen von Code, so können initiale Ladezeiten verringert werden, oder selten genutze Features erst bei Bedarf geladen werden.<br>
        <code><pre lang="javascript">
    let modulePath = "src/irgendeinModul.js";

    import(modulePath) 
        .then(obj => tu was mit dem importierten modul)
        .catch(err => fehlermeldung);
        </pre></code></li>
    </ul>
</article>
<article>
    <h2>Syntax</h2>
    <ul>
        <li>Benannte Exports:
            <ul>
                <li>Export:<br>
                <code><pre lang="javascript">
    // Modul "my-module.js"
    function cube(x) {
        return x * x * x;
    }
    const foo = Math.PI + Math.SQRT2;
    export { cube, foo };   
                </pre></code>
                </li>
                <li>Import:<br>
                <code><pre lang="javascript">
    import { cube, foo } from 'my-module.js';
    console.log(cube(3)); // 27
    console.log(foo);    // 4.555806215962888
                </pre></code>
                </li>
            </ul>
        </li>
        <li>Standard Exports (Nur einer pro Datei):
            <ul>
                <li>Export:<br>
                <code><pre lang="javascript">
    // Modul "my-module.js"
    export default function cube(x) {
        return x * x * x;
    }  
                </pre></code>
                </li>
                <li>Import:<br>
                <code><pre lang="javascript">
    import myFunction from 'my-module.js';
    console.log(myFunction(3)); // 27
                </pre></code>
                </li>              
            </ul>
        </li>
    </ul>
</article>
</section>
    
</main>
</div><script type="text/javascript" src="./resources/js/JsFills.js"></script>
<script type="text/javascript" src="./resources/js/JsCodeEditor.js"></script>
<script type="text/javascript" src="./resources/js/HtmlCodeEditor.js"></script>
<script type="text/javascript" src="./resources/js/initEditors.js"></script>
<script type="text/javascript" src="./resources/js/buildIndex.js"></script>
</body>
</html>