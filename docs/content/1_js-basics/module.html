<h2>Warum Module?</h2>
<ul>
    <li>Die Zerlegung in kleinere gekapselte Programmteile fördert die Übersicht und Codequalität.</li>
    <li>Diese kleineren Module können leicht in anderen Projekten wiederverwendet werden.</li>
    <li>Modular geschriebene Programme erlauben sogenanntes "Tree Shaking", d.h. nicht verwendete Module werden bei Builds ignoriert.</li>
    <li>Module können theoretisch Webseitenübergreifend gecached werden.</li>
    <li>Module erlauben dynamisches Nachladen von Code, so können initiale Ladezeiten verringert werden, oder selten genutze Features erst bei Bedarf geladen werden.<br>
    <code><pre lang="javascript">
let modulePath = "src/irgendeinModul.js";

import(modulePath) 
    .then(obj => tu was mit dem importierten modul)
    .catch(err => fehlermeldung);
    </pre></code></li>
    <li>Nicht exportierte Variablen und Methoden sind nicht von außerhalb des Moduls erreichbar. (vergleichbar mit 'private' in anderen Sprachen)</li>
</ul>

<h2>Syntax</h2>
<ul>
    <li>Benannte Exports:
        <ul>
            <li>Export:<br>
            <code><pre lang="javascript">
// Modul "my-module.js"
function cube(x) {
    return x * x * x;
}
const foo = Math.PI + Math.SQRT2;
export { cube, foo };   
            </pre></code>
            </li>
            <li>Import:<br>
            <code><pre lang="javascript">
import { cube, foo } from 'path_to/my-module.js';
console.log(cube(3)); // 27
console.log(foo);    // 4.555806215962888
            </pre></code>
            </li>
        </ul>
    </li>
    <li>Default Export (Nur einer pro Datei):
        <ul>
            <li>Export:<br>
            <code><pre lang="javascript">
// Modul "my-module.js"
export default function cube(x) {
    return x * x * x;
}  
            </pre></code>
            </li>
            <li>Import:<br>
            <code><pre lang="javascript">
import myFunction from 'path_to/my-module.js';
console.log(myFunction(3)); // 27
            </pre></code>
            </li>              
        </ul>
    </li>
</ul>